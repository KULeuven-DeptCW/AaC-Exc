\documentclass{article}
\title{Automaten en Berekenbaarheid:\\opgave 2}
\author{Prof. B. Demoen (\url{Bart.Demoen@cs.kuleuven.be})\\ W. Van Onsem (\url{Willem.VanOnsem@cs.kuleuven.be})}
\date{11 december 2014}
\usepackage{../assignment-nl,../brackets}
\newcommand{\lang}[1]{\textsc{#1}}
\newcommand{\RegEx}[0]{\ensuremath{\mbox{RegEx}}}
\begin{document}
\maketitle
\richtlijnen{}

\begin{question}[Berekenbaarheid]
Zijn volgende talen herkenbaar, co-herkenbaar en/of beslisbaar? Indien wel, beschrijf een beslisser/herkenner. Indien niet, toon dit aan (bijvoorbeeld aan de hand van een reductie). $\Sigma$ slaat altijd op het invoeralfabet van een machine. $L_M$ slaat op de taal die beslist wordt door $M$. De machines zijn allemaal Turing machines.
\begin{enumerate}
 \item $\condset{\tupl{M}}{\exists s_1,s_2\in L_M:\abs{s_1}\neq\abs{s_2}}$;
 \item $\condset{\tupl{M,s}}{\mbox{$M$ stopt na hoogstens $2^{\abs{s}}$ stappen bij invoer $s$}}$;
 \item $\condset{\tupl{M}}{\mbox{$M$ stopt voor iedere invoer $s\in\Sigma^{\star}$ na hoogstens $2^{\abs{s}}$}}$; en
 \item $\condset{\tupl{M,y}}{\mbox{$M$ beweegt de lees/schrijf-kop ooit naar links bij invoer $y$}}$.
\end{enumerate}
\begin{answer}~~
\begin{enumerate}
 \item $\condset{\tupl{M}}{\exists s_1,s_2\in L_M:\abs{s_1}\neq\abs{s_2}}$
 \begin{enumerate}
  \item \textbf{niet beslisbaar}: dit volgt rechtstreeks uit de \emph{Stelling van Rice}. De taal is niet \emph{triviaal}: we kunnen een Turing machine construeren die de taal $\accl{a,aa}$ beslist en een Turing machine die de taal $\accl{a}$ beslist. De ene machine zit in de taal de andere niet. De taal is ook \emph{taal-invariant}: er zijn geen aspecten van de Turing machine opgenomen in de voorwaarde.
  \item \textbf{herkenbaar}: We beschrijven een herkenner. Deze herkenner werkt in fases beginnend met fase $0$. In fase $i$ wordt er voor elke string $s\in\Sigma^i$ een Turing machine opgestart (gesimuleerd) en worden alle tot dusver begonnen Turing machines een stap verder gezet. Wanneer er twee Turing machines accepteren en de strings hebben een verschillende lengte, accepteren we ook.
  \item \textbf{niet co-herkenbaar}: immers is de taal herkenbaar en niet beslisbaar.
 \end{enumerate}
 \item $\condset{\tupl{M,s}}{\mbox{$M$ stopt na hoogstens $2^{\abs{s}}$ stappen bij invoer $s$}}$
 \begin{enumerate}
  \item \textbf{beslisbaar}: We beschrijven een beslisser. Laat $M$ lopen op $s$ als na $2^{\abs{s}}$ stappen nog is afgelopen, verwerpen we $\tupl{M,s}$; indien de simulatie stopt voor of op $2^{\abs{s}}$ stappen, accepteren we.
  \item \textbf{herkenbaar}: volgt uit het feit dat de taal beslisbaar is.
  \item \textbf{co-herkenbaar}: volgt uit het feit dat de taal beslisbaar is.
 \end{enumerate}
 \item $\condset{\tupl{M}}{\mbox{$M$ stopt voor iedere invoer $s\in\Sigma^{\star}$ na hoogstens $2^{\abs{s}}$}}$
 \begin{enumerate}
  \item \textbf{niet-beslisbaar}: 
  \item \textbf{niet herkenbaar}: 
  \item \textbf{co-herkenbaar}: 
 \end{enumerate}
 \item $\condset{\tupl{M,y}}{\mbox{$M$ beweegt de lees/schrijf-kop ooit naar links bij invoer $y$}}$
 \begin{enumerate}
  \item \textbf{beslisbaar}: we beschrijven een beslisser. We simuleren de Turing machine $M$ met een soort debugger (een programma die $M$ een stap laat zetten, maar nadien het geheugen, etc. kan inspecteren). In eerste instantie draaien we de Turing machine tot deze voorbij de invoer leest. Indien de Turing machine probeert naar links te bewegen, dan verwerpen we natuurlijk onmiddellijk. Verder kunnen we ook lusdetectie uitvoeren: wanneer de Turing machine blijft stilstaan houden we de combinaties van toestanden en karakters die onder de tape staan bij. Wanneer we eenzelfde koppel een tweede maal tegenkomen, weten we dat we in een oneindige lus zitten en accepteren we: immers leidt deze lus nooit tot het naar links bewegen van de kop.
  \paragraph{}
  Wanneer we het invoergedeelte van 
  \item \textbf{herkenbaar}: volgt uit het feit dat de taal beslisbaar is.
  \item \textbf{co-herkenbaar}: volgt uit het feit dat de taal beslisbaar is.
 \end{enumerate}
\end{enumerate}
\end{answer}
\end{question}

\begin{question}[Inwendige operaties]
Stel twee verschillende niet-beslisbare talen $L_1$ en $L_2$, geef voor elke uitspraak hieronder aan:
\begin{enumerate}
 \item indien de uitspraak waar is voor elke $L_1$ en $L_2$, waarom (bewijs);
 \item indien de uitspraak afhangt van de keuze voor $L_1$ en $L_2$: twee voorbeelden (voor het geval waar de uitspraak klopt en voor het geval waar de uitspraak niet klopt); en
 \item indien de uitspraak niet klopt, een tegenvoorbeeld of reden.
\end{enumerate}
Uitspraken:
\begin{enumerate}
 \item $L_1\setminus L_2$ is herkenbaar;
 \item $L_1\cap L_2$ is beslisbaar; en
 \item $L_1\cup L_2$ is herkenbaar.
\end{enumerate}
\end{question}

\begin{question}[synchrone PDA]
Een sPDA is een PDA met $2$ stapels, maar waarbij stapels synchroon moeten bewegen: beide stapels ``pushen'' en ``poppen'' op hetzelfde ogenblik. Het is met andere woorden niet toegelaten dat \'e\'en stapel groeit terwijl de andere wordt afgebouwd. Is een sPDA strikt\footnote{Met ``strikt'' bedoelen we dat een sPDA minstens \'e\'en taal meer kan beslissen dan een gewone PDA.} sterker dan een gewone PDA? Bewijs je antwoord.
\begin{answer}
Een sPDA is niet sterker dan een PDA. We bewijzen dat beide automaten even krachtig zijn door constructies tussen een sPDA en PDA te geven in beide richtingen.
\begin{enumerate}
 \item Een PDA naar een sPDA.
 \begin{construction}
  Gegeven een PDA $\tupl{Q,\Sigma,\Gamma,\delta,q_s,F}$, we beschouwen een PDA $\tupl{Q,\Sigma,\Gamma,\delta',q_s,F}$ die dezelfde taal beslist met volgende overgangsregels:
  \begin{equation}
  \forall q\in Q,\sigma\in\Sigma,\gamma,\gamma_2\in\Gamma_{\epsilon}:\fun{\delta'}{q,\sigma,\gamma,\gamma_2}=\condset{\tupl{q',\gamma',\gamma'}}{\tupl{q',\gamma'}\in\fun{\delta}{q,\sigma,\gamma}}
  \end{equation}
  We hebben hier gekozen om dezelfde inhoud te ``pushen'' op de tweede stapel (maar men zou bijvoorbeeld ook altijd hetzelfde karakter kunnen pushen). Er wordt verder nooit gekeken naar het karakter op de tweede stapel: het is eender wat daar staat, al weten we dat dit altijd hetzelfde is als de eerste stapel.
 \end{construction}
 \item Een sPDA naar een PDA.
 \begin{construction}
  Gegeven een sPDA $\tupl{Q,\Sigma,\Gamma,\delta,q_s,F}$ we beschouwen een PDA $\tupl{Q,\Sigma,\Gamma\times\Gamma,\delta',q_s,F}$
 \end{construction}
\end{enumerate}
\end{answer}
\end{question}

\begin{question}[Bezige bever]
Stel dat de bezige bever functie $\fun{S}{n}$ toch berekenbaar is. Beschrijf een Turing machine op hoog niveau die $A_{\rm TM}$ kan beslissen.
\begin{answer}
De bezige bever beschrijft het maximale aantal stappen dat een Turing machine met alfabet $\accl{0,1}$ kan zetten, zonder in een oneindige lus te geraken. We kunnen dus een (gemodificeerde) Turing machine laten lopen en het aantal tot dusver gezette stappen bijhouden. Wanneer dit aantal over dat van de bezige bever gaat, 

\paragraph{}
Er zijn echter enkele problemen: de Turing machine kan een willekeurig alfabet hebben, en de invoer staat aanvankelijk op de tape, de tape is dus niet leeg.
\end{answer}
\end{question}

\end{document}